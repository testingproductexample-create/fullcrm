#!/usr/bin/env python3
"""
Penetration Testing Preparation Toolkit
Tools and scripts for preparing and conducting penetration tests
"""

import json
import os
import subprocess
import logging
import time
import ipaddress
import socket
import threading
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, asdict
from enum import Enum
import smtplib
import requests
import nmap
from concurrent.futures import ThreadPoolExecutor, as_completed

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TestPhase(Enum):
    PLANNING = "planning"
    RECONNAISSANCE = "reconnaissance"
    VULNERABILITY_ASSESSMENT = "vulnerability_assessment"
    EXPLOITATION = "exploitation"
    POST_EXPLOITATION = "post_exploitation"
    DOCUMENTATION = "documentation"

class TestScope(Enum):
    EXTERNAL = "external"
    INTERNAL = "internal"
    WEB_APPLICATION = "web_application"
    NETWORK = "network"
    WIRELESS = "wireless"
    SOCIAL_ENGINEERING = "social_engineering"

@dataclass
class TestTarget:
    """Represents a penetration test target"""
    id: str
    name: str
    description: str
    ip_addresses: List[str]
    domains: List[str]
    ports: List[int]
    protocols: List[str]
    test_scope: TestScope
    restrictions: List[str]
    contact_info: Dict[str, str]
    access_credentials: Optional[Dict[str, str]]

@dataclass
class PentestFinding:
    """Represents a penetration test finding"""
    id: str
    target_id: str
    title: str
    description: str
    severity: str  # Critical, High, Medium, Low, Informational
    cvss_score: float
    affected_systems: List[str]
    proof_of_concept: str
    remediation: str
    references: List[str]
    timestamp: datetime

class PentestPreparation:
    """Main penetration testing preparation engine"""
    
    def __init__(self, config_dir: str = "assessment"):
        self.config_dir = config_dir
        os.makedirs(config_dir, exist_ok=True)
        
        # Load configurations
        self.questionnaire_config = self._load_questionnaire_config()
        self.test_templates = self._load_test_templates()
        self.tools_config = self._load_tools_config()
        
        # Test management
        self.active_tests = {}
        self.completed_tests = []
        self.test_results = {}
        
        logger.info("Penetration Testing Preparation Toolkit initialized")
    
    def _load_questionnaire_config(self) -> Dict[str, Any]:
        """Load security assessment questionnaire configuration"""
        try:
            with open(f"{self.config_dir}/questionnaires.json", 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            logger.warning("Questionnaire configuration not found, using defaults")
            return self._get_default_questionnaire_config()
    
    def _get_default_questionnaire_config(self) -> Dict[str, Any]:
        """Get default questionnaire configuration"""
        return {
            "security_assessment_questionnaires": {
                "infrastructure_security": {
                    "title": "Infrastructure Security Assessment",
                    "sections": []
                }
            }
        }
    
    def _load_test_templates(self) -> Dict[str, Any]:
        """Load penetration test templates"""
        return {
            "external_network_test": {
                "name": "External Network Penetration Test",
                "description": "Test external-facing systems and services",
                "phases": [
                    {
                        "name": "Reconnaissance",
                        "duration": "2-4 hours",
                        "activities": [
                            "OSINT gathering",
                            "DNS enumeration",
                            "Service discovery",
                            "Banner grabbing"
                        ]
                    },
                    {
                        "name": "Vulnerability Assessment",
                        "duration": "4-6 hours",
                        "activities": [
                            "Port scanning",
                            "Service enumeration",
                            "Vulnerability scanning",
                            "Web application assessment"
                        ]
                    },
                    {
                        "name": "Exploitation",
                        "duration": "6-8 hours",
                        "activities": [
                            "Exploit public vulnerabilities",
                            "Attempt privilege escalation",
                            "Test for authentication bypass",
                            "Network lateral movement"
                        ]
                    }
                ],
                "deliverables": [
                    "Executive summary report",
                    "Technical findings report",
                    "Proof of concept demonstrations",
                    "Remediation recommendations",
                    "Network topology diagram"
                ]
            },
            "internal_network_test": {
                "name": "Internal Network Penetration Test",
                "description": "Test internal network security and lateral movement",
                "phases": [
                    {
                        "name": "Reconnaissance",
                        "duration": "2-3 hours",
                        "activities": [
                            "Network discovery",
                            "Service enumeration",
                            "User enumeration",
                            "Share discovery"
                        ]
                    },
                    {
                        "name": "Vulnerability Assessment",
                        "duration": "4-5 hours",
                        "activities": [
                            "Host scanning",
                            "Service scanning",
                            "Vulnerability scanning",
                            "Configuration review"
                        ]
                    },
                    {
                        "name": "Lateral Movement",
                        "duration": "6-10 hours",
                        "activities": [
                            "Credential harvesting",
                            "Pass-the-hash attacks",
                            "Kerberoasting",
                            "Domain enumeration"
                        ]
                    }
                ],
                "deliverables": [
                    "Network security assessment report",
                    "Privilege escalation findings",
                    "Data exfiltration scenarios",
                    "Credential compromise results",
                    "Remediation roadmap"
                ]
            },
            "web_application_test": {
                "name": "Web Application Penetration Test",
                "description": "Comprehensive web application security testing",
                "phases": [
                    {
                        "name": "Reconnaissance",
                        "duration": "1-2 hours",
                        "activities": [
                            "Application mapping",
                            "Technology stack identification",
                            "Directory enumeration",
                            "Input identification"
                        ]
                    },
                    {
                        "name": "Automated Testing",
                        "duration": "2-3 hours",
                        "activities": [
                            "Automated vulnerability scanning",
                            "Static code analysis",
                            "Dynamic application testing",
                            "API testing"
                        ]
                    },
                    {
                        "name": "Manual Testing",
                        "duration": "6-12 hours",
                        "activities": [
                            "Authentication testing",
                            "Authorization testing",
                            "Input validation testing",
                            "Business logic testing",
                            "Session management testing"
                        ]
                    }
                ],
                "deliverables": [
                    "Web application security assessment",
                    "OWASP Top 10 compliance report",
                    "API security assessment",
                    "Source code review findings",
                    "Secure development recommendations"
                ]
            }
        }
    
    def _load_tools_config(self) -> Dict[str, Any]:
        """Load tools configuration"""
        return {
            "network_tools": {
                "nmap": {
                    "description": "Network discovery and security auditing",
                    "commands": [
                        "nmap -sS -sV -O target_ip",
                        "nmap -sU -p target_ports target_ip",
                        "nmap -sC -A target_ip"
                    ]
                },
                "masscan": {
                    "description": "High-speed port scanner",
                    "commands": [
                        "masscan target_ip -p80,443,22,21,25,53,8080,8443"
                    ]
                }
            },
            "web_tools": {
                "burp_suite": {
                    "description": "Web application security testing platform",
                    "features": [
                        "Proxy interception",
                        "Scanner",
                        "Intruder",
                        "Repeater"
                    ]
                },
                "nikto": {
                    "description": "Web server scanner",
                    "commands": [
                        "nikto -h http://target_ip",
                        "nikto -h https://target_ip -ssl"
                    ]
                }
            },
            "exploitation_tools": {
                "metasploit": {
                    "description": "Penetration testing framework",
                    "modules": [
                        "exploit modules",
                        "payload modules",
                        "auxiliary modules",
                        "post-exploitation modules"
                    ]
                }
            }
        }
    
    def create_pentest_plan(self, 
                          test_type: str, 
                          target_info: Dict[str, Any], 
                          start_date: datetime,
                          duration_days: int) -> str:
        """Create a comprehensive penetration test plan"""
        
        if test_type not in self.test_templates:
            raise ValueError(f"Unknown test type: {test_type}")
        
        template = self.test_templates[test_type]
        plan_id = f"PENTEST-{datetime.now().strftime('%Y%m%d')}-{len(self.active_tests) + 1}"
        
        # Create test target
        target = TestTarget(
            id=f"TARGET-{plan_id}",
            name=target_info.get('name', 'Test Target'),
            description=target_info.get('description', ''),
            ip_addresses=target_info.get('ip_addresses', []),
            domains=target_info.get('domains', []),
            ports=target_info.get('ports', [80, 443, 22, 21, 25, 53]),
            protocols=target_info.get('protocols', ['HTTP', 'HTTPS', 'SSH', 'FTP', 'SMTP', 'DNS']),
            test_scope=TestScope.EXTERNAL,
            restrictions=target_info.get('restrictions', []),
            contact_info=target_info.get('contact_info', {}),
            access_credentials=target_info.get('access_credentials')
        )
        
        # Create test plan
        test_plan = {
            "plan_id": plan_id,
            "test_type": test_type,
            "template": template,
            "target": asdict(target),
            "start_date": start_date.isoformat(),
            "end_date": (start_date + timedelta(days=duration_days)).isoformat(),
            "phases": [],
            "deliverables": template["deliverables"],
            "team_assignments": {},
            "status": "planned",
            "created_at": datetime.now().isoformat()
        }
        
        # Generate detailed phases
        for phase in template["phases"]:
            phase_detail = {
                "name": phase["name"],
                "description": f"Execute {phase['name'].lower()} activities",
                "duration": phase["duration"],
                "activities": phase["activities"],
                "tools": self._get_phase_tools(phase["name"]),
                "deliverables": self._get_phase_deliverables(phase["name"]),
                "status": "pending",
                "assigned_to": None,
                "start_date": None,
                "end_date": None
            }
            test_plan["phases"].append(phase_detail)
        
        # Save test plan
        self.active_tests[plan_id] = test_plan
        
        # Generate test documentation
        self._generate_test_documentation(plan_id)
        
        logger.info(f"Penetration test plan created: {plan_id}")
        return plan_id
    
    def _get_phase_tools(self, phase_name: str) -> List[str]:
        """Get tools for a specific phase"""
        tool_mapping = {
            "Reconnaissance": ["nmap", "masscan", "whois", "dig", "shodan", "censys"],
            "Vulnerability Assessment": ["nmap", "nessus", "openvas", "nikto", "dirb", "gobuster"],
            "Exploitation": ["metasploit", "burp_suite", "sqlmap", "msfvenom"],
            "Post-Exploitation": ["mimikatz", "bloodhound", "empire", "cobalt_strike"],
            "Web Application Testing": ["burp_suite", "owasp_zap", "sqlmap", "dirb", "nikto"]
        }
        return tool_mapping.get(phase_name, [])
    
    def _get_phase_deliverables(self, phase_name: str) -> List[str]:
        """Get deliverables for a specific phase"""
        deliverable_mapping = {
            "Reconnaissance": [
                "Network topology diagram",
                "Service enumeration results",
                "Technology stack identification",
                "Attack surface analysis"
            ],
            "Vulnerability Assessment": [
                "Vulnerability scan results",
                "Risk assessment matrix",
                "Prioritized vulnerability list",
                "False positive analysis"
            ],
            "Exploitation": [
                "Proof of concept demonstrations",
                "Exploit success rate analysis",
                "Lateral movement paths",
                "Privilege escalation results"
            ],
            "Web Application Testing": [
                "OWASP Top 10 assessment",
                "Authentication bypass tests",
                "Authorization test results",
                "Input validation findings"
            ]
        }
        return deliverable_mapping.get(phase_name, [])
    
    def _generate_test_documentation(self, plan_id: str):
        """Generate test plan documentation"""
        test_plan = self.active_tests[plan_id]
        
        # Create documentation directory
        doc_dir = f"assessment/pentest_docs/{plan_id}"
        os.makedirs(doc_dir, exist_ok=True)
        
        # Generate test plan document
        plan_doc = {
            "test_plan": test_plan,
            "methodology": self._get_test_methodology(test_plan["test_type"]),
            "rules_of_engagement": self._generate_roe(test_plan),
            "test_schedule": self._generate_test_schedule(test_plan),
            "communication_plan": self._generate_communication_plan(test_plan),
            "risk_assessment": self._generate_risk_assessment(test_plan)
        }
        
        # Save documentation
        with open(f"{doc_dir}/test_plan.json", 'w') as f:
            json.dump(plan_doc, f, indent=2, default=str)
        
        # Generate test execution checklist
        self._generate_execution_checklist(plan_id, doc_dir)
        
        logger.info(f"Test documentation generated: {doc_dir}")
    
    def _get_test_methodology(self, test_type: str) -> Dict[str, Any]:
        """Get testing methodology for test type"""
        return {
            "framework": "PTES (Penetration Testing Execution Standard)",
            "phases": [
                "Pre-engagement Interactions",
                "Intelligence Gathering",
                "Threat Modeling",
                "Vulnerability Analysis",
                "Exploitation",
                "Post-Exploitation",
                "Reporting"
            ],
            "test_approach": "Black box testing" if test_type == "external_network_test" else "Gray box testing",
            "tools_approach": "Automated and manual testing",
            "documentation_standards": [
                "OWASP Testing Guide v4.0",
                "NIST SP 800-115",
                "SANS Pen Testing Standards"
            ]
        }
    
    def _generate_roe(self, test_plan: Dict[str, Any]) -> Dict[str, Any]:
        """Generate rules of engagement"""
        return {
            "scope": {
                "authorized_targets": test_plan["target"]["ip_addresses"] + test_plan["target"]["domains"],
                "restricted_areas": test_plan["target"].get("restrictions", []),
                "time_constraints": f"Business hours only (9 AM - 5 PM EST)",
                "testing_windows": "Outside of peak business hours preferred"
            },
            "methodology": {
                "testing_approach": test_plan.get("test_approach", "Gray box testing"),
                "tools_allowed": "All industry-standard penetration testing tools",
                "attack_simulation": "Realistic attack scenarios without actual damage"
            },
            "restrictions": {
                "denial_of_service": "No DoS or DDoS attacks",
                "social_engineering": "Requires explicit approval",
                "physical_access": "Requires explicit approval",
                "data_destruction": "No data destruction or modification",
                "production_systems": "Minimal impact on production systems"
            },
            "emergency_procedures": {
                "incident_response": "Immediate contact with target team if issues arise",
                "rollback_procedures": "All changes must be reversible",
                "communication": "24/7 contact information provided"
            }
        }
    
    def _generate_test_schedule(self, test_plan: Dict[str, Any]) -> Dict[str, Any]:
        """Generate test execution schedule"""
        start_date = datetime.fromisoformat(test_plan["start_date"])
        
        schedule = {
            "total_duration": (datetime.fromisoformat(test_plan["end_date"]) - start_date).days,
            "phases": []
        }
        
        current_date = start_date
        for phase in test_plan["phases"]:
            phase_schedule = {
                "phase_name": phase["name"],
                "start_date": current_date.isoformat(),
                "duration": phase["duration"],
                "end_date": (current_date + timedelta(days=2)).isoformat(),  # Assume 2 days per phase
                "activities": phase["activities"],
                "deliverables": phase["deliverables"]
            }
            schedule["phases"].append(phase_schedule)
            current_date += timedelta(days=2)
        
        return schedule
    
    def _generate_communication_plan(self, test_plan: Dict[str, Any]) -> Dict[str, Any]:
        """Generate communication plan"""
        return {
            "contacts": test_plan["target"]["contact_info"],
            "communication_schedule": {
                "daily_check_ins": "Daily status updates during testing",
                "phase_completion": "Summary upon completion of each phase",
                "critical_findings": "Immediate notification of critical findings",
                "test_completion": "Final summary and preliminary findings"
            },
            "reporting": {
                "real_time_updates": "Slack/Teams channel for real-time communication",
                "formal_reports": "Email reports for official findings",
                "presentation": "Executive presentation at test completion"
            }
        }
    
    def _generate_risk_assessment(self, test_plan: Dict[str, Any]) -> Dict[str, Any]:
        """Generate risk assessment for the test"""
        return {
            "identified_risks": [
                {
                    "risk": "Service disruption during vulnerability scanning",
                    "probability": "Medium",
                    "impact": "Low",
                    "mitigation": "Use conservative scan rates and test during off-hours"
                },
                {
                    "risk": "False positives in vulnerability detection",
                    "probability": "High",
                    "impact": "Low",
                    "mitigation": "Manual verification of all automated findings"
                },
                {
                    "risk": "Unintended data access or exposure",
                    "probability": "Low",
                    "impact": "High",
                    "mitigation": "Strict adherence to scope and ROE"
                }
            ],
            "mitigation_strategies": [
                "Implement testing safeguards",
                "Use safe testing tools and configurations",
                "Maintain detailed logs of all activities",
                "Regular communication with target team"
            ],
            "contingency_plans": {
                "service_issues": "Immediate rollback and notification",
                "security_breach": "Cease testing and notify incident response team",
                "scope_clarification": "Contact test coordinator for guidance"
            }
        }
    
    def _generate_execution_checklist(self, plan_id: str, doc_dir: str):
        """Generate detailed execution checklist"""
        test_plan = self.active_tests[plan_id]
        
        checklist = {
            "test_id": plan_id,
            "pre_test_checklist": [
                "☐ Review and sign Rules of Engagement",
                "☐ Confirm test scope and targets",
                "☐ Verify contact information",
                "☐ Set up testing environment",
                "☐ Install and configure testing tools",
                "☐ Prepare test documentation templates",
                "☐ Conduct team briefing",
                "☐ Schedule initial kickoff meeting"
            ],
            "phase_checklists": {}
        }
        
        for phase in test_plan["phases"]:
            phase_checklist = {
                "activities": [f"☐ {activity}" for activity in phase["activities"]],
                "tools": [f"☐ Configure {tool}" for tool in self._get_phase_tools(phase["name"])],
                "deliverables": [f"☐ Create {deliverable}" for deliverable in phase["deliverables"]],
                "testing": [
                    "☐ Execute planned tests",
                    "☐ Document findings",
                    "☐ Verify results",
                    "☐ Take screenshots/evidence",
                    "☐ Update test tracking"
                ]
            }
            checklist["phase_checklists"][phase["name"]] = phase_checklist
        
        checklist["post_test_checklist"] = [
            "☐ Compile all findings and evidence",
            "☐ Perform quality assurance review",
            "☐ Prepare executive summary",
            "☐ Create technical report",
            "☐ Schedule presentation meeting",
            "☐ Archive test artifacts",
            "☐ Conduct team debrief",
            "☐ Submit final deliverables"
        ]
        
        # Save checklist
        with open(f"{doc_dir}/execution_checklist.json", 'w') as f:
            json.dump(checklist, f, indent=2)
    
    def run_network_scan(self, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """Run network reconnaissance scan"""
        target_ip = target_info.get("target_ip")
        if not target_ip:
            raise ValueError("Target IP address required")
        
        results = {
            "scan_id": f"SCAN-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
            "target": target_ip,
            "timestamp": datetime.now().isoformat(),
            "scan_type": "network_reconnaissance",
            "results": {}
        }
        
        try:
            # Port scan
            logger.info(f"Starting port scan for {target_ip}")
            nm = nmap.PortScanner()
            nm.scan(target_ip, arguments='-sS -sV -O --script=safe')
            
            # Process results
            for host in nm.all_hosts():
                host_info = {
                    "ip": host,
                    "hostname": nm[host].hostname(),
                    "state": nm[host].state(),
                    "osmatch": nm[host].get('osmatch', []),
                    "services": {}
                }
                
                # Process open ports
                for proto in nm[host].all_protocols():
                    ports = nm[host][proto].keys()
                    for port in ports:
                        service = nm[host][proto][port]
                        host_info["services"][port] = {
                            "name": service.get('name', 'unknown'),
                            "version": service.get('version', 'unknown'),
                            "product": service.get('product', 'unknown'),
                            "state": service.get('state', 'unknown')
                        }
                
                results["results"][host] = host_info
            
            logger.info(f"Network scan completed for {target_ip}")
            return results
            
        except Exception as e:
            logger.error(f"Network scan failed: {e}")
            results["error"] = str(e)
            return results
    
    def generate_vulnerability_report(self, scan_results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate vulnerability assessment report from scan results"""
        report = {
            "report_id": f"VULN-{datetime.now().strftime('%Y%m%d-%H%M%S')}",
            "scan_results": scan_results,
            "vulnerabilities": [],
            "risk_summary": {
                "critical": 0,
                "high": 0,
                "medium": 0,
                "low": 0,
                "informational": 0
            },
            "recommendations": []
        }
        
        # Process scan results for common vulnerabilities
        for host, host_info in scan_results.get("results", {}).items():
            for port, service in host_info.get("services", {}).items():
                service_name = service.get("name", "").lower()
                
                # Check for common vulnerable services
                vulnerabilities = self._check_service_vulnerabilities(service_name, service.get("version", ""))
                
                for vuln in vulnerabilities:
                    finding = PentestFinding(
                        id=f"FINDING-{len(report['vulnerabilities']) + 1}",
                        target_id=host,
                        title=vuln["title"],
                        description=vuln["description"],
                        severity=vuln["severity"],
                        cvss_score=vuln.get("cvss_score", 0.0),
                        affected_systems=[f"{host}:{port}"],
                        proof_of_concept=vuln.get("poc", ""),
                        remediation=vuln["remediation"],
                        references=vuln.get("references", []),
                        timestamp=datetime.now()
                    )
                    
                    report["vulnerabilities"].append(asdict(finding))
                    report["risk_summary"][vuln["severity"].lower()] += 1
        
        # Generate recommendations based on findings
        report["recommendations"] = self._generate_vulnerability_recommendations(report["vulnerabilities"])
        
        return report
    
    def _check_service_vulnerabilities(self, service_name: str, service_version: str) -> List[Dict[str, Any]]:
        """Check service for known vulnerabilities"""
        vulnerabilities = []
        
        # Database of known vulnerable services
        vulnerable_services = {
            "ftp": {
                "default_creds": {
                    "title": "Default FTP Credentials",
                    "description": "FTP service using default or weak credentials",
                    "severity": "High",
                    "cvss_score": 7.5,
                    "remediation": "Change default passwords and implement strong authentication",
                    "references": ["CWE-1391"]
                }
            },
            "ssh": {
                "weak_ciphers": {
                    "title": "Weak SSH Encryption Ciphers",
                    "description": "SSH service using weak or deprecated encryption ciphers",
                    "severity": "Medium",
                    "cvss_score": 5.3,
                    "remediation": "Configure SSH to use only strong encryption algorithms",
                    "references": ["RFC 4253", "RFC 4254"]
                }
            },
            "http": {
                "version_disclosure": {
                    "title": "HTTP Version Disclosure",
                    "description": "Web server version information disclosed in headers",
                    "severity": "Low",
                    "cvss_score": 3.1,
                    "remediation": "Configure web server to hide version information",
                    "references": ["OWASP-A6"]
                }
            },
            "mysql": {
                "weak_credentials": {
                    "title": "MySQL Weak Credentials",
                    "description": "MySQL database accessible with weak or default credentials",
                    "severity": "Critical",
                    "cvss_score": 9.8,
                    "remediation": "Implement strong passwords and restrict database access",
                    "references": ["CWE-1391"]
                }
            }
        }
        
        # Check if service has known vulnerabilities
        if service_name in vulnerable_services:
            for vuln_name, vuln_info in vulnerable_services[service_name].items():
                vulnerabilities.append(vuln_info)
        
        return vulnerabilities
    
    def _generate_vulnerability_recommendations(self, vulnerabilities: List[Dict[str, Any]]) -> List[str]:
        """Generate recommendations based on vulnerabilities found"""
        recommendations = []
        
        # Count vulnerabilities by severity
        severity_counts = {}
        for vuln in vulnerabilities:
            severity = vuln.get("severity", "Low")
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        # Generate specific recommendations
        if severity_counts.get("Critical", 0) > 0:
            recommendations.append("Immediate action required: Address all Critical severity vulnerabilities within 24 hours")
        
        if severity_counts.get("High", 0) > 0:
            recommendations.append("High priority: Patch or remediate High severity vulnerabilities within 1 week")
        
        if severity_counts.get("Medium", 0) > 0:
            recommendations.append("Plan remediation: Address Medium severity vulnerabilities within 30 days")
        
        # General recommendations
        recommendations.extend([
            "Implement a regular vulnerability scanning program",
            "Establish a patch management process",
            "Consider implementing a Web Application Firewall (WAF)",
            "Conduct regular security awareness training for staff",
            "Review and update incident response procedures"
        ])
        
        return recommendations
    
    def create_executive_summary(self, pentest_results: Dict[str, Any]) -> Dict[str, Any]:
        """Create executive summary of penetration test results"""
        
        # Extract key metrics
        total_vulnerabilities = len(pentest_results.get("vulnerabilities", []))
        critical_count = sum(1 for v in pentest_results.get("vulnerabilities", []) if v.get("severity") == "Critical")
        high_count = sum(1 for v in pentest_results.get("vulnerabilities", []) if v.get("severity") == "High")
        
        # Calculate risk score
        risk_score = (critical_count * 4 + high_count * 3 + 
                     sum(1 for v in pentest_results.get("vulnerabilities", []) if v.get("severity") == "Medium") * 2 +
                     sum(1 for v in pentest_results.get("vulnerabilities", []) if v.get("severity") == "Low") * 1)
        
        # Determine overall risk level
        if critical_count > 0 or risk_score > 20:
            risk_level = "Critical"
        elif high_count > 3 or risk_score > 15:
            risk_level = "High"
        elif total_vulnerabilities > 10:
            risk_level = "Medium"
        else:
            risk_level = "Low"
        
        summary = {
            "executive_summary": {
                "test_scope": pentest_results.get("scan_results", {}).get("target", "Unknown"),
                "test_date": pentest_results.get("scan_results", {}).get("timestamp", ""),
                "total_vulnerabilities": total_vulnerabilities,
                "critical_vulnerabilities": critical_count,
                "high_vulnerabilities": high_count,
                "overall_risk_level": risk_level,
                "risk_score": risk_score
            },
            "key_findings": [
                f"Identified {total_vulnerabilities} security vulnerabilities",
                f"{critical_count} critical, {high_count} high severity issues require immediate attention",
                f"Overall security posture rated as {risk_level} risk"
            ],
            "business_impact": {
                "potential_data_breach": critical_count > 0,
                "system_compromise_risk": high_count > 0,
                "compliance_implications": risk_level in ["Critical", "High"],
                "reputational_risk": critical_count > 0
            },
            "immediate_actions": [
                "Patch all Critical and High severity vulnerabilities",
                "Implement additional monitoring for affected systems",
                "Review access controls and authentication mechanisms",
                "Conduct security awareness training"
            ],
            "recommendations": [
                "Develop a comprehensive vulnerability management program",
                "Implement regular penetration testing schedule",
                "Establish security incident response procedures",
                "Consider engaging security consultants for remediation guidance"
            ]
        }
        
        return summary
    
    def export_pentest_report(self, plan_id: str, output_format: str = "pdf") -> str:
        """Export complete penetration test report"""
        if plan_id not in self.active_tests:
            raise ValueError(f"Test plan {plan_id} not found")
        
        test_plan = self.active_tests[plan_id]
        
        # Generate comprehensive report
        report = {
            "test_plan": test_plan,
            "executive_summary": test_plan.get("executive_summary", {}),
            "methodology": self._get_test_methodology(test_plan["test_type"]),
            "findings": test_plan.get("findings", []),
            "recommendations": test_plan.get("recommendations", []),
            "appendices": {
                "rules_of_engagement": test_plan.get("roe", {}),
                "test_schedule": test_plan.get("schedule", {}),
                "tools_used": list(self.tools_config.keys()),
                "references": [
                    "OWASP Testing Guide v4.0",
                    "NIST SP 800-115",
                    "PTES (Penetration Testing Execution Standard)"
                ]
            }
        }
        
        # Save report
        output_file = f"assessment/reports/{plan_id}_report.json"
        os.makedirs(os.path.dirname(output_file), exist_ok=True)
        
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2, default=str)
        
        logger.info(f"Penetration test report exported: {output_file}")
        return output_file

def main():
    """Main function to test the penetration testing toolkit"""
    toolkit = PentestPreparation()
    
    # Test plan creation
    target_info = {
        "name": "Test Web Application",
        "description": "Test target for penetration testing",
        "ip_addresses": ["192.168.1.100"],
        "domains": ["test.example.com"],
        "ports": [80, 443, 22, 21],
        "contact_info": {
            "primary_contact": "test@example.com",
            "backup_contact": "backup@example.com"
        }
    }
    
    try:
        # Create test plan
        plan_id = toolkit.create_pentest_plan(
            test_type="web_application_test",
            target_info=target_info,
            start_date=datetime.now() + timedelta(days=7),
            duration_days=5
        )
        
        print(f"Penetration test plan created: {plan_id}")
        
        # Test network scanning
        scan_results = toolkit.run_network_scan({"target_ip": "127.0.0.1"})
        print(f"Network scan completed: {len(scan_results.get('results', {}))} hosts found")
        
        # Test vulnerability report generation
        vuln_report = toolkit.generate_vulnerability_report(scan_results)
        print(f"Vulnerability report generated: {len(vuln_report.get('vulnerabilities', []))} findings")
        
        # Test executive summary
        exec_summary = toolkit.create_executive_summary(vuln_report)
        print(f"Executive summary created: {exec_summary['executive_summary']['overall_risk_level']} risk level")
        
        # Export report
        report_file = toolkit.export_pentest_report(plan_id)
        print(f"Report exported to: {report_file}")
        
        print("Penetration testing toolkit test completed successfully!")
        
    except Exception as e:
        logger.error(f"Test failed: {e}")
        raise

if __name__ == "__main__":
    main()